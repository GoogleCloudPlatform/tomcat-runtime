/*
 * Copyright (C) 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.cloud.runtimes.tomcat.session;

import com.google.common.annotations.VisibleForTesting;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.catalina.Manager;
import org.apache.catalina.session.StandardSession;

/**
 * A partial implementation of the {@link StandardSession} meant to work with persistent key-value
 * storage.
 *
 * @param <K> The key type of the storage
 * @param <E> The entity type that holds the stored values
 */
public abstract class KeyValuePersistentSession<K, E> extends StandardSession {

  protected Set<String> accessedAttributes;
  protected Set<String> initialAttributes;

  /**
   * Create a new session which can be stored in the storage.
   *
   * @param manager The session manager which manage this session.
   */
  public KeyValuePersistentSession(Manager manager) {
    super(manager);
    this.accessedAttributes = new HashSet<>();
    this.initialAttributes = new HashSet<>();
  }

  protected abstract K getKeyForEntity(E entity);

  protected abstract String getNameFromKey(K key);

  protected abstract void setAttributeFromEntity(E entity)
      throws IOException, ClassNotFoundException;

  /**
   * Serialize an attribute an embed it into an entity whose key is generated by the provided key
   * function.
   *
   * @param attributeKeyFunction The function to use to create the key for the entity.
   * @param name The name of the attribute to serialize.
   * @return An Entity containing the serialized attribute.
   */
  protected abstract E serializeAttribute(Function<String, K> attributeKeyFunction,
      String name);

  /**
   * Restore the metadata of a session with the values contains in the entity.
   *
   * @param metadata An entity containing the metadata to restore
   */
  protected abstract void restoreMetadataFromEntity(E metadata);

  /**
   * Store the metadata of the session in an entity.
   *
   * @param sessionKey Identifier of the session on the storage
   * @return An entity containing the metadata.
   */
  @VisibleForTesting
  protected abstract E saveMetadataToEntity(K sessionKey);

  /**
   * Restore the attributes and metadata of the session from storage entities.
   *
   * @param entities An iterator of entity, containing the metadata and attributes of the session.
   * @throws ClassNotFoundException The class in attempt to be deserialized is not present.
   * @throws IOException Error during the deserialization of the object.
   */
  public void restoreFromEntities(K sessionKey, Iterable<E> entities) throws
      ClassNotFoundException, IOException {
    E metadataEntity = null;
    List<E> attributeEntities = new LinkedList<>();
    for (E entity : entities) {
      if (getKeyForEntity(entity).equals(sessionKey)) {
        metadataEntity = entity;
      } else {
        attributeEntities.add(entity);
      }
    }

    if (metadataEntity == null) {
      throw new IOException("The serialized session is missing the metadata entity");
    }

    restoreMetadataFromEntity(metadataEntity);
    restoreAttributesFromEntity(attributeEntities);
    setId(getNameFromKey(sessionKey));
    initialAttributes.addAll(Collections.list(getAttributeNames()));
  }

  /**
   * Deserialize the content of each entity and add them as attribute of the session.
   *
   * @param entities The entities containing the serialized attributes.
   * @throws IOException If an error occur during the deserialization
   * @throws ClassNotFoundException If the class being deserialized is not present in this program.
   */
  private void restoreAttributesFromEntity(Iterable<E> entities) throws IOException,
      ClassNotFoundException {
    for (E entity : entities) {
      setAttributeFromEntity(entity);
    }
  }

  /**
   * Serialize the session metadata and attributes into entities storable in the storage.
   *
   * @param sessionKey The key of the serialized session
   * @param attributeKeyFunction A key function used to generate the key for the attributes.
   * @return A list of entities containing the metadata and each attribute.
   * @throws IOException If an error occur during the serialization.
   */
  public List<E> saveToEntities(K sessionKey, Function<String, K> attributeKeyFunction)
      throws
      IOException {
    List<E> entities = saveAttributesToEntity(attributeKeyFunction);
    entities.add(saveMetadataToEntity(sessionKey));
    return entities;
  }

  /**
   * Serialize the session attributes into entities.
   *
   * @param attributeKeyFunction The key function for the entities.
   * @return A list of entities where the key correspond to the name of the attribute and the
   *      property `value` to the serialized attribute.
   * @throws IOException If an error occur during the serialization.
   */
  @VisibleForTesting
  List<E> saveAttributesToEntity(Function<String, K> attributeKeyFunction) throws
      IOException {
    Stream<E> entities = Collections.list(getAttributeNames()).stream()
        .filter(name -> accessedAttributes.contains(name))
        .filter(name -> isAttributeDistributable(name, getAttribute(name)))
        .map(name -> serializeAttribute(attributeKeyFunction, name));

    try {
      return entities.collect(Collectors.toList());
    } catch (UncheckedIOException e) {
      throw e.getCause();
    }
  }

  /**
   * List the attributes that were present at the beginning of the request and suppressed during its
   * execution. This is used to reflect the suppression of attributes in the storage (The suppressed
   * attributes would be left unchanged in the storage otherwise).
   *
   * @return A set of the suppressed attributes.
   */
  public Set<String> getRemovedAttributes() {
    Set<String> removedAttributes = new HashSet<>(initialAttributes);
    removedAttributes.removeAll(Collections.list(getAttributeNames()));
    return removedAttributes;
  }

  @Override
  public Object getAttribute(String name) {
    accessedAttributes.add(name);
    return super.getAttribute(name);
  }

  @Override
  public void setAttribute(String name, Object value, boolean notify) {
    super.setAttribute(name, value, notify);
    if (notify) {
      accessedAttributes.add(name);
    }
  }

  @VisibleForTesting
  class SessionMetadata {

    public static final String CREATION_TIME = "creationTime";
    public static final String LAST_ACCESSED_TIME = "lastAccessedTime";
    public static final String MAX_INACTIVE_INTERVAL = "maxInactiveInterval";
    public static final String IS_NEW = "isNew";
    public static final String IS_VALID = "isValid";
    public static final String THIS_ACCESSED_TIME = "thisAccessedTime";
    public static final String EXPIRATION_TIME = "expirationTime";
    public static final String ATTRIBUTE_VALUE_NAME = "value";
  }
}
